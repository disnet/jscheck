\documentclass{article}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{float}
 
\floatstyle{ruled}
\newfloat{program}{thp}{lop}
\floatname{program}{Snippet}


\begin{document}

\title{Project Report - Limited Static Type Checking for JavaScript}
\author{Huascar A. Sanchez \and Tim Disney}

\maketitle

\lstset{showstringspaces=false}

\section{Introduction}
In the construction of software it is generally cheaper to 
catch programming errors earlier in the development cycle. One common method 
to catch errors is static type checking. This will
check the type consistency of the program before it is even
run. If the code has any type violations the type checker will 
find it and alert the programmer.

For example, in strongly typed languages like Java it is impossible 
to invoke a method which has not been defined for a class (unless reflection is used).
The compiler will immediately 
complain and prevent the program from compiling. However, in languages like 
JavaScript, this kind of error will not be discovered until runtime.

Adding static type checking to a dynamic language like JavaScript is a 
challenge, especially since objects can be modified at runtime. Given this challenge, 
we have implemented a static type checker, called JSCheck, for user-defined objects 
in JavaScript. The scope of JSCheck is limited to properties on an object's
prototype. In other words, we are completely ignoring type checking of the built in types
such as strings and numbers. The whole idea, as Lucas Cardelli said \cite{typesystems}, 
is to prevent the occurrence of errors during program execution. 

The rest of this paper is divided as follows. Section (\ref{sec:types}) gives an overview
of how user-defined types work in JavaScript, section (\ref{sec:implementation}) 
will discuss the design and implementation choices that were made through the development 
of JSCheck, related work will be discussed in (\ref{sec:related}), and future work
and conclusions in (\ref{sec:future}) and (\ref{sec:conclusion}).


\section{Types in JavaScript}
\label{sec:types}
User-defined types in JavaScript can be written in a variety of styles and forms. The form
that we considered in the scope of this project is object creation using 
constructor functions and prototype modification.

\begin{program}
\begin{verbatim}
function Dog(){
  // ..
}

Dog.prototype.getName = function(){
  //..
}

Dog.prototype.bark = function(){
  //..
}

var mydog = new Dog();
\end{verbatim}
\caption{Checking Types in JavaScript}
\label{fig:object}
\end{program}

For example, in code snippet (\ref{fig:object}) we define a {\tt Dog} type
which has two methods, {\tt getName} and {\tt bark} which are added to the {\tt Dog}
prototype. New ``instances'' of the {\tt Dog} type can be created with the {\tt new}
keyword.

There are other ways of creating objects including using object literal notation
and assigning methods directly to fields of an object but these techniques of 
object creation are not included in the scope JSCheck.

To enable JSCheck to check the usages of an object we add the comment type annotation
to the JavaScript language as seen in snippet \ref{fig:check}. In
this example the {\tt fido} parameter has been annotated with the {\tt Dog}
type in the {\tt //\#} comment. JSCheck will then check that all usages of
the {\tt fido} parameter conforms to the definition of the {\tt Dog} type.

\begin{program}
\begin{verbatim}
//# @type Dog fido
function useDog(fido) {
  fido.bark();
}

var mydog = new Dog();
useDog(mydog);
\end{verbatim}
\caption{Type Checking}
\label{fig:check}
\end{program}


\section{Implementation}
\label{sec:implementation}
JSCheck is implemented in Haskell. We were originally considering defining a 
subset of JavaScript to ease the burden of creating a parser for JavaScript. 
However we found a Haskell library called HJS \cite{hjsLibrary} 
which implements a full parser for JavaScript (ECMAScript 3rd edition plus 
some additions from JavaScript 1.5). We needed to make a few modifications to
HJS in order to pick up the type annotations but this greatly simplified much of
the effort in the implementation of JSCheck.

As seen in figure \ref{fig:jscheckway} In general terms JSCheck works by taking in a JavaScript source file and running
a modified version of the HJS parser over it. This produces a abstract syntax tree
that is fed into a type extractor function which finds all the JavaScript object types that
has been defined in the source. The output of this function is a list of types (type names and all associated fields)
which is fed into a type checker function along with the original AST. The
checker function find all functions that have been annotated with our special
type comments and checks all usages of parameters against the extracted types. 
If there are any usages of unknown fields the checker fails with a warning that
the source could not be checked.

Because of the dynamic nature of JavaScript our implementation is both unsound 
and incomplete. It is unsound because methods could be add to the object at
runtime so even though the checker sees a usage of an unknown field that field
actually could be defined. It is incomplete because fields could also be removed
from an object at runtime. The JavaScript program could be accessing non existent 
fields even though the checker thought they were there.

Unless you explicity type annotate your functions, JScheck does not have the means 
for type checking them. The way our checker works is very straightforward. It a
three-steps process (see Figure ~\ref{fig:jscheckway}). First, it takes some JavaScript 
code and parses it. The output is an Abstract Syntax Tree (AST). Second, given this AST, 
it extracts all the possible types found in your code. The output is what we know 
as the environment. The environment is the place where type names are mapped to 
their available type fields. Third, the environment and the AST are then fed to 
a built-in type checking process. Here is where any type consistency will be checked 
and, if there are any, type consistency violations will be communicated to the 
developer. 

\begin{figure}[here]
  \begin{center}
    \includegraphics[scale=0.5]{blockdiagram.png}
  \end{center}
  \caption{Type Checking - the JSCheck way}
  \label{fig:jscheckway}
\end{figure}
\pagebreak



As could see in the above figure, after the code has been parsed, the JScheck will 
extract the types and check them on functions that have type annotations. The final 
output will be either your code is well-typed or not (represented as a boolean value). 
We plan on changing this output to a more descriptive one (i.e., including where the
type violation occurred, the name of the function, and a suggestion for how to fix it). 


\section{Related Work}
\label{sec:related}
We are not the first ones who have tried to implement static type checking for JavaScript.
There have been others who have done it before us. Some of them include:

\begin{description}
  \item[Tom Austin and Caitlin Sadowski] \hfill \\ 
  developed a structural type-checker for Javascript \cite{fwjsStruct}.
  \item[$JS_0$ team] \hfill \\ 
  developed a formalism for an object based language called JSO, which includes features of JavaScript 
  \cite{typeinferenceforjavascriptEcoop,typecheckingforjavascript}. 
  \item[DRuby team] \hfill \\ 
  developed Diamondback Ruby (DRuby), a tool that blends Ruby's dynamic type 
  system with a static typing discipline \cite{typecheckingruby}.
  \item[Google] developed the Closure compiler \cite{closureCompiler}.  
\end{description}

In some way, which remains obscure, we all shared the same drive for making type 
checking possible in a dynamic language. We chose JavaScript for many reasons. 
However, the most important one, for us, was that JavaScript is the most used 
language in the World Wide Web and providing this type checking capability would
be appreciated by many. 

Our implementation is both unsound and incomplete. One thing that sets our 
implementation apart for previous work is that our checker works (in a limited 
fashion) for full JavaScript.

One thing that sets our 
implementation apart for previous work is that our checker works (in a limited fashion) for
full JavaScript.

\section{Future Work}
\label{sec:future}
There are several areas in our static type checker that could be expanded. One of
them, as indicated above, is the type checking output. Future will be focused on 
providing a more descriptive type checking output. Another extension could be to
provide type consistency checks for other elements of the language, like strings
and numbers.

%TODO: talk about other forms of object creation


\section{Conclusion}
\label{sec:conclusion}
We have developed a static type checker for prototype based objects in JavaScript
called JSCheck. By using this checker any developer will be able to catch any 
type errors before running their programs. The only thing the developer needs to
do is to explicitly type annotate a function(s). The rest is done by JSCheck. 

The idea of implementing a type checker strongly motivated us. It is hard for us 
describe the feeling of accomplishment after completing our implementation. Now,
for sure, we have a better understanding of what static type checking is all about. 

Full source can be found at {\tt http://github.com/disnet/jscheck}.

\bibliographystyle{abbrv}
\bibliography{report}

\end{document}


